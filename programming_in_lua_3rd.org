#+TITLE: programming in lua^3rd
#+AUTHOR: kumakichi

* chapter 1

** comment
starts anywhere with a double hyphen (- -) and runs until the end of the line

start with - -[ [ and rununtil the next ]]

** global variables
do not need declarations

* chapter 2

Lua is a dynamically typed language

** types

nil booleans numbers strings literal-strings long-strings

#+BEGIN_SRC lua
> info=[[
>> name lili
>> age 20]]
> print(info)
#+END_SRC

can add any number of equal signs between the two open brackets, 

as in *[===[*,ends only at the next closing brackets with the same

 number of equal signs in between *]===]*

This same facility is valid for comments, too
*--[=[*, *]=]*

** \z for long strings
lua 5.2 offers the escape sequence *\z*, it skips all subsequent characters in the string until the first non-space character

#+BEGIN_SRC lua
data = "\x00\x01\z
         \x02\x03"
#+END_SRC

The \z at the end of the first line skips the following end-of-line and the inden-
tation of the next line, so that the byte \x01 is directly followed by \x02 in the
resulting string.

** Coercions

Lua provides automatic conversions between numbers and strings at run time
#+BEGIN_SRC lua
> print("10"+1)
11
> print("10+1")
10+1
#+END_SRC

whenever Lua finds a number where it expects a string, it converts the number to a string

#+BEGIN_SRC lua
> print(1 .. 2) -- .. is the string concatenation operator in Lua
12
#+END_SRC

use function 'tonumber' to convert a string to a number explicitly

** tables

The table type implements associative arrays,seems like 'map' in golang

#+BEGIN_SRC lua
> a={}
> for i=1,100 do a[i] = i*2 end
> print(a[ 9])
18
> print(a['y'])
nil
> a.x=10
> print(a['x'])
10
#+END_SRC

be careful of the difference between a.x and a[x]:

the first form represents a["x"], that is, a table indexed by the string "x". 

The second form is a table indexed by the value of the variable x.

#+BEGIN_SRC lua
> a={}
> x="y"
> a[x]=10
> print(a["y"])
10
> print(a["x"])
nil
#+END_SRC
 
** userdata and threads

The userdata type allows arbitrary C data to be stored in Lua variables(interface in golang?)

* expressions

** arithmetic operators
#+BEGIN_SRC lua
+ - * / ^(exponentiation) %(modulo)
#+END_SRC

#+BEGIN_SRC lua
> print(4^0.5)
2

> x=math.pi
> print(x-x%0.01)
3.14
#+END_SRC

** relational operators

#+BEGIN_QUOTE
< > <= >= == ~=(negation of equality)
#+END_QUOTE

** logical operators

and or not

** concatenation

'..'

** length operator

'#' 

#+BEGIN_SRC lua
> a={1,2,3,nil,nil}
> print(#a)
3
#+END_SRC

** table constructors

index of table starts from *1*, not *0*

#+BEGIN_SRC lua
> days={"monday","tuesday"}
> print(days[ 1])
monday


> tmp={color="red",
>> age=27,
>> {x=0,y=0},                   -- tmp[ 1]
>> {x=1,y=1}                    -- tmp[ 2]
>> }
#+END_SRC

fields with string indices that are not proper identifiers, use square brackets:
#+BEGIN_SRC lua

> opnames={["+"]="add",["-"]="sub"}

> sunday = "monday"; monday = "sunday"
> t = {sunday = "monday", [sunday] = monday}
> print(t.sunday, t[sunday], t[t.sunday])
monday	sunday	sunday

> tmp={color="red"}
> print(tmp.color)
red
> print(tmp[color])
nil
> print(tmp["color"])
red
#+END_SRC

* statements

just the same as go

#+BEGIN_SRC lua
> x=3
> a,b=1,x*2
> a,b=b,a
> print(a,b)
6	1
#+END_SRC

** local variables and blocks

A block is the body of a control structure, the body of a function, 

or a chunk (the file or string where the variable is declared):

#+BEGIN_SRC lua
x = 10
local i = 1                     -- local to the chunk

while i<=x do
   local x = i*2                -- local to the while body
   print(x)
   i=i+1
end
#+END_SRC

A common idiom in Lua is : local foo = foo,this code creates a local

variable, foo, and initializes it with the value of the global variable foo

** control structures

*** if then else end

#+BEGIN_SRC lua
if op == "+" then
	r = a + b
elseif op == "-" then
	r = a - b
else
	r = 0
end
#+END_SRC

*** while

#+BEGIN_SRC lua
while i<x do
	print(i)
end
#+END_SRC

*** repeat

#+BEGIN_SRC lua
-- print the first non-empty input line

repeat
	line = io.read()
until line ~= ""

print(line)
#+END_SRC

*** for

**** numeric for

#+BEGIN_SRC lua
-- [start,end] step

> for i=1,10,2 do print(i) end
1
3
5
7
9
#+END_SRC

**** generic for

#+BEGIN_SRC lua
> a={color="red","hello"}
> for k,v in pairs(a) do print(k,v) end
1	hello
color	red
#+END_SRC

*** break return goto

goto can simulate some constructions

#+BEGIN_SRC lua
  i=0
  while i<10 do
     if i % 2 == 1 then goto continue end
     print(i)
  
        ::continue::
        i=i+1
  end
#+END_SRC

* functions

** multiple results

#+BEGIN_SRC lua
  function maximum (a)
     local idx = 1
     local max = a[idx]
     for i=1,#a do
        if a[i] > max then
           idx = i;max = a[i]
        end
     end
     return idx,a[idx]
  end
  
  print(maximum({3,7,8,6}))
#+END_SRC

unpack 

#+BEGIN_SRC lua
  -- predefined version
  
  > print(table.unpack({1,2,3,4,5},2,4))
  2   3   4
  
  -- lua version
  function lua_unpack (t,s,e)
     s = s or 1
     e = e or #t
     if s <= e then
        return t[s],lua_unpack(t,s+1,e)
     end
  end
#+END_SRC

** variadic functions

#+BEGIN_SRC lua
  function sum (...)
     print("Calling sum with vars :",...)
     local sum = 0
     local args = table.pack(...)
     print("vals num :", args.n)
     for k,v in ipairs{...} do
        sum = sum + v
     end
     local a,b = ...
     print(a,b)
     return sum
  end
#+END_SRC

** named arguments

#+BEGIN_SRC lua
  function Window(args)
     if type(args.title) ~= "string" then
        error("no title")
     elseif type(args.width) ~= "number" then
        error("no width")
     elseif type(args.height) ~= "number" then
        error("no height")
     end
  
     -- everything else is optional
     return {
        title=args.title,
        width=args.width, height=args.height,
        x = args.x or 0,         -- default x is 0
        y = args.y or 0,         -- default y is 0
        border = args.border      -- default border is nil
     }
  end
  
  function PrintWindow(w)
     for k,v in pairs(w) do
        print(k,v)
     end
  end
  
  PrintWindow(Window{title="Demo",width=640,height=480})
#+END_SRC

the derivative of a function f in a point x is the value of (f (x + d) − f (x))/d when d becomes infinitesimally small

#+BEGIN_SRC lua
  function derivative (f, delta)
     delta = delta or 1e-4
     return function (x)
        return (f(x+delta)-f(x))/delta
     end
  end
  
  c = derivative(math.sin)
  pi = math.pi
  
  print(c(pi),math.cos(pi))
#+END_SRC

** closures

When we write a function enclosed in another function, it has full access to local variables from the enclosing function; we call this feature lexical scoping

#+BEGIN_SRC lua
  function counter()
     local i=0
     return function()
        i=i+1
        return i
     end
  end
  
  c = counter()
  
  for i=1,3 do
     print(c())
  end
#+END_SRC

do everything in 'local'

#+BEGIN_SRC lua
  -- bad way
  -- local x = print
  -- x(3)
  -- x(x)
  
  -- good way
  do
     local x = print
     x(3)
  end
  x(x) -- error, x is nil
#+END_SRC

** non-global functions

#+BEGIN_SRC lua
  -- Lib = {}
  -- Lib.add = function (a,b) return a+b end
  -- Lib.sub = function (a,b) return a-b end
  
  Lib = {
     add = function (a,b) return a+b end,
     sub = function (a,b) return a-b end
  }
#+END_SRC

** proper tail calls

Lua does tail-call elimination,which means that Lua is properly tail recursive

In Lua, only a call with the form *return func(args)* is a tail call

#+BEGIN_SRC lua
  function fibo(n,a,b)
     if n == 0 then
        return a
     else
        return fibo(n-1,a+b,a) -- position 'a' hold sumed value
     end
  end
#+END_SRC

* iterators and the generic for

** iterators and closures

#+BEGIN_SRC lua
  function values(t)
     local i=0
     return function () i=i+1; return t[i] end
  end
  
  x={1,2,3}
  iterator=values(x)
  
  -- one way
  
  while true do
     local element = iterator()
     if element == nil then break end
     print(element)
  end
  
  -- another way
  for val in values(x) do
     print(val)
  end
#+END_SRC

** the semantics of generic for

#+BEGIN_SRC lua
for <var-list> in <exp-ilst> do
	<body>
end
#+END_SRC

Here, var-list is a list of one or more variable names, separated by commas, and exp-list is a list of one or more expressions, also separated by commas

These expressions should result in the three values kept by the for: the iterator function, the invariant state, and the initial value for the control variable

remember *for* will adjust its expression list to *3* results,extra values being discarded or nils added as needed

After this initialization step, the for calls the iterator function with two arguments: the invariant state and the control variable

#+BEGIN_SRC lua
  function iter (a,i)
     i=i+1
     local v=a[i]
     if v ~= nil then
        return i,v                -- the first retval will be used as the new value of the control variable
     end
  end
  
  function lua_ipairs(a)
     return iter,a,0              -- iterator function, invariant state, initial value for the control variable
  end
  
  for k,v in lua_ipairs({1,2,3}) do
     print(k,v)                   -- lua calls iter(a,0), iter(a,1) ...
  end
#+END_SRC

** stateless iterators

The key point is: do not use closure

The state of the iteration is the table being traversed (that is the invariant state, which does not change during the loop), plus the current index (the control variable)

#+BEGIN_SRC lua
  for k,v in next,{1,2,3} do      -- iter->'next',invariant->'{1,2,3}',nil
     print(k,v)
  end
#+END_SRC

#+BEGIN_SRC lua
  -- linked list,insert at head
  
  function getnext (list, node)
     if not node then
        return list
     else
        return node.next
     end
  end
  
  function traverse (list)
     return getnext, list, nil
  end
  
  -- use it
  do
     local list = nil
     for line in io.lines() do
        list = {val = line, next = list}
     end
  
     for node in traverse(list) do
        print(node.val)
     end
  end
  
  -- but i think, it may be more clearly int this way
  function getnext (list, node)
     if not node then
        node = list
     else
        node = node.next
     end
     return node
  end
#+END_SRC

** iterators with complex state

Frequently, an iterator needs to keep more state than fits into a single invariant state and a control variable.

Although the state is always the same table (and therefore *invariant*), the table *contents* change along the loop.

*TABLE* not changed, but the *CONTENT* changed

#+BEGIN_SRC lua
  function allwords()
     local state={line=io.read(),pos=1}
     return iter,state,nil
  end
  
  function iter(state)
     while state.line do -- repeat while there are lines
        -- search for next word
        local s, e = string.find(state.line, "%w+", state.pos)
        if s then
           -- found a word?
           -- update next position (after this word)
           state.pos = e + 1
           return string.sub(state.line, s, e)
        else
           -- word not found
           state.line = io.read() -- try next line...
           state.pos = 1
           -- ... from first position
        end
     end
     return nil
  end
  
  for v in allwords() do
     print(v)
  end
#+END_SRC

** true iterators

#+BEGIN_SRC lua
  function allwords(f)
     for line in io.lines() do
        for word in string.gmatch(line,"%w+") do
           f(word)
        end
     end
  end
  
  allwords(print)
#+END_SRC

* complilation,execution,errors

** complilation

#+BEGIN_SRC lua
  i = 32
  local i = 0
  
  f = load("i=i+1;print(i)")
  g = function() i=i+1;print(i) end
  f()                             -- because load always compiles its chunks in the global environment
  
  g()
#+END_SRC

#+BEGIN_SRC lua
  -- foo.lua
  -- 
  -- function foo(x)
  --    print(x)
  -- end
  
  f = loadfile("foo.lua")
  print(foo)                      -- nil(foo is compiled, but it is not defined yet
  )
  f()                             -- define foo
  print(foo)                      -- function: 0x8b6ed20
#+END_SRC

** precompiled code

#+BEGIN_SRC sh
luac -o foo.lc foo.lua
#+END_SRC

Code in precompiled form is not always smaller than the original, but it loads faster

** c code

The loadlib function loads the given library and links Lua to it, it returns the C function as a Lua function.

local path = "/usr/local/lib/lua/5.1/socket.so"
local f = package.loadlib(path, "luaopen_socket")

** error

#+BEGIN_SRC lua
  print "enter a number:"
  -- n = io.read("*n")
  -- if not n then error("you should input a number") end
  
  -- 'assert' equals the 2 lines above 
  -- The assert function checks whether its first argument is not false and simply returns this argument; if the argument is false, assert raises an error
  n = assert(io.read("*n"),"you should input a number")
  print(n)
#+END_SRC

** error handling and exceptions

#+BEGIN_SRC lua
  local ok,msg = pcall(function()
        n=io.read()
        assert(tonumber(n),"not a number")
        return tonumber(n)
  end)
  
  if ok then
     print(msg)
  else
     print("not ok")
  end
#+END_SRC

** error messages and tracebacks

#+BEGIN_SRC lua
print(debug.traceback())
#+END_SRC

#+BEGIN_SRC lua
  function foo (str)
     if type(str) ~= "string" then
        error("string expected",2) -- here,2 means the error comes not from 'foo', but the caller of 'foo'
     end
     return "hello " .. str
  end
  
  function bar()
     print(foo("sanye"))
     print(foo(3))
  end
  
  bar()
#+END_SRC

* coroutines

** coroutine basics

#+BEGIN_SRC lua
  demo=coroutine.create(function () print("hi") end)
  print(demo)                     -- thread: 0x9410a70
  print(coroutine.status(demo))   -- suspended
  coroutine.resume(demo)          -- use 'resume' to start/restart coroutine
#+END_SRC

The real power of coroutines stems from the yield function,which allows a running coroutine to suspend its own execution so that it can be resumed later

#+BEGIN_SRC lua
  demo=coroutine.create(function () 
        for i=1,10 do
           print("demo",i)
           coroutine.yield()
        end
  end)
  
  coroutine.resume(demo)          -- 1
  coroutine.resume(demo)          -- 2
#+END_SRC

#+BEGIN_SRC lua
  demo=coroutine.create(function () 
        return 3,4
  end)
  
  print(coroutine.resume(demo))   -- true    3   4
  print(coroutine.resume(demo))   -- false   cannot resume dead coroutine
#+END_SRC

Lua offers what we call *asymmetric coroutines* (which means that it has a function to suspend the execution of a coroutine and a different function to resume a suspended coroutine)

Some other languages offer *symmetric coroutines*, where there is only one function to transfer control from any coroutine to another

Some people call asymmetric coroutine *semi-coroutines* (being not symmetrical, they are not really co)

** pipes and filters

#+BEGIN_SRC lua
  producer = coroutine.create(function ()
        while true do
           local x=io.read()
           send(x)
        end
  end)
  
  function consumer ()
     while true do
        local x = receive()
        if x ~= nil then
           io.write(x,"\n")
        else
           return
        end
     end
  end
  
  function receive ()
     local status,val = coroutine.resume(producer) -- cosumer wake 'producer' up
     return val
  end
  
  function send (x)
     coroutine.yield(x)
  end
  
  consumer()
#+END_SRC

a better way

#+BEGIN_SRC lua
  function receive (prod)         -- producer func
     local status,val = coroutine.resume(prod)
     return val
  end
  
  function send (x)
     coroutine.yield(x)
  end
  
  function producer ()
     return coroutine.create(function ()
           while true do
              local x = io.read()
              send(x)
           end
     end)
  end
  
  function filter (prod)
     return coroutine.create(function ()
           for line=1,math.huge do
              local x=receive(prod)
              x=string.format("%-5d %s",line,x)
              send(x)
           end
     end)
  end
  
  function consumer (prod)
     while true do
        local x = receive(prod)
        io.write(x,"\n")
     end
  end
  
  consumer(filter(producer()))
#+END_SRC

** coroutines as iterators

#+BEGIN_SRC lua
  function permgen (a, n)
     n = n or #a
     if n <= 1 then
        coroutine.yield(a)
     else
        for i = 1, n do
           a[n], a[i] = a[i], a[n]
           permgen(a, n - 1)
           a[n], a[i] = a[i], a[n]
        end
     end
  end
  
  function printResult (a)
     for i = 1, #a do
        io.write(a[i], " ")
     end
     io.write("\n")
  end
  
  function permutations (a, n)
     -- local co = coroutine.create(function() permgen(a,n) end)
     -- return function ()
     --    local ok,result = coroutine.resume(co)
     --    return result
     -- end
     return coroutine.wrap(function() permgen(a,n) end)
  end
  
  for p in permutations{"a","b","c"} do
     printResult(p)
  end
#+END_SRC

Unlike create, wrap does not return the coroutine itself; instead, it returns a function that, when called, resumes the coroutine. 

Unlike the original resume, that function does not return an error code as its first result; instead, it raises the error in case of error

** non-preemptive multithreading

coroutines are non-preemptive, which means while a coroutine is running, it cannot be stopped from the outside

* data structures

** queues and double queues

#+BEGIN_SRC lua
  List={}                         -- namespace
  
  function List.new ()
     return {first = 0, last = -1}
  end
  
  function List.pushfirst (list, value)
     local first = list.first - 1
     list.first = first
     list[first] = value
  end
  
  function List.pushlast (list, value)
     local last = list.last + 1
     list.last = last
     list[last] = value
  end
  
  function List.popfirst (list)
     local first = list.first
     assert(first<=list.last, "list is empty")
     local value = list[first]
     list[first] = nil   -- to allow garbage collection
     list.first = first + 1
     return value
  end
  
  function List.poplast (list)
     local last = list.last
     assert(list.first <= last, "list is empty")
     local value = list[last]
     list[last] = nil   -- to allow garbage collection
     list.last = last - 1
     return value
  end
  
  l = List.new()
  
  for i = 1,10 do
     List.pushfirst(l,i)
  end
  
  for i = 1,10 do
     print(List.popfirst(l))
  end
#+END_SRC

** sets and bags

Bags, also called multisets, differ from regular sets in that each element can appear multiple times

#+BEGIN_SRC lua
  -- set
  s={"red","blue"}
  
  -- bag
  Bag = {
     new = function ()
        return {}
     end,
     insert = function (b,element)
        b[element] = (b[element] or 0) + 1
     end,
     remove = function (b, element)
        local count = b[element]
        b[element] = (count and count > 1) and count - 1 or nil
     end
  }
#+END_SRC

** string buffers

#+BEGIN_SRC lua
  local buff = ""
  for line in io.lines() do
     buff = buff .. line .. "\n"  -- poor performance when processing large files
  end
#+END_SRC

for each new line,lua allocates a large buff,copy,move,growing...

this way

#+BEGIN_SRC lua
  local t = {}
  for line in io.lines() do
     t[#t + 1] = line
  end
  local s = table.concat(t, "\n")
#+END_SRC

* data files and persistence

tmp.lua
#+BEGIN_QUOTE
Entry{
   author = "Donald E. Knuth",
   title = "Literate Programming",
   publisher = "CSLI",
   year = 1992
}

Entry{
   author = "Jon Bentley",
   title = "More Programming Pearls",
   year = 1990,
   publisher = "Addison-Wesley",
}
#+END_QUOTE

#+BEGIN_SRC lua
  local authors={}
  
  function Entry(b)
     authors[b.author] = b.title
  end
  
  dofile("tmp.lua")
  
  for k,v in pairs(authors) do
     print(v," is written by ", k)
  end
#+END_SRC

* metatables and metamethords

Each value in Lua can have an associated metatable

#+BEGIN_SRC lua
  local t={}
  local t1={}
  
  print(getmetatable(t))          -- nil
  setmetatable(t,t1)
  print(getmetatable(t))          -- table: 0x8967da8
#+END_SRC

** arithmetic metamethods

#+BEGIN_SRC lua
  mt = {}
  Set = {}
  
  -- create a new set with the values of a given list
  function Set.new (l)
     local set = {}
     setmetatable(set, mt)
     for _, v in ipairs(l) do set[v] = true end
     return set
  end
  
  function Set.union (a, b)
     local res = Set.new{}
     for k in pairs(a) do res[k] = true end
     for k in pairs(b) do res[k] = true end
     return res
  end
  
  function Set.intersection (a, b)
     local res = Set.new{}
     for k in pairs(a) do
        res[k] = b[k]
     end
     return res
  end
  
  -- presents a set as a string
  function Set.tostring (set)
     local l = {}
     -- list to put all elements from the set
     for e in pairs(set) do
        l[#l + 1] = e
     end
     return "{" .. table.concat(l, ", ") .. "}"
  end
  
  -- print a set
  function Set.print (s)
     print(Set.tostring(s))
  end
  
  s1 = Set.new{10, 20, 30, 50}
  s2 = Set.new{30, 1}
  
  mt.__add = Set.union
  mt.__mul = Set.intersection
  
  Set.print(s1+s2)
  Set.print((s1 + s2)*s1)
#+END_SRC

** relational metamethods

__eq __lt __le

#+BEGIN_SRC lua
  mt = {}
  Set = {}
  
  function Set.new (l)
     local set = {}
     setmetatable(set, mt)
     for _, v in ipairs(l) do set[#set+1] = v end
     return set
  end
  
  mt.__eq = function (a,b)
     if #a == #b then return true end
     return false
  end
  
  a = Set.new{1,2,3}
  b = Set.new{4,5,6}
  print(a==b)
#+END_SRC

** library-defined metamethods

Functions setmetatable and getmetatable also use a metafield, in this case to protect metatables

#+BEGIN_SRC lua
  mt = {}
  Set = {}
  
  function Set.new ()
     local set = {}
     setmetatable(set, mt)
     return set
  end
  
  mt.__metatable = "hello world"
  print(getmetatable(Set.new()))
#+END_SRC

** table-access metamethods

*** __index

#+BEGIN_SRC lua
  mt = {}
  Set = {x=1,y=2,width=640,height=480}
  
  mt.__index = function (_, key)
     return Set[key]
  end
  
  function new (o)
     setmetatable(o,mt)
     return o
  end
  
  w = new{x=3,y=4}
  print(w.width)
#+END_SRC

*** __newindex

The __newindex metamethod does for table updates what __index does for table accesses

*** table with default values

#+BEGIN_SRC lua
  local mt = {__index = function (t) return t.xxoo end}
  function setDefault (t,d)
     t.xxoo = d
     setmetatable(t,mt)
  end
  
  tmp={x=1,y=2}
  setDefault(tmp,88)
  print(tmp.z)                    -- 88
#+END_SRC

If we are worried about name clashes, it is easy to ensure the uniqueness of the special key

#+BEGIN_SRC lua
  local key = {}                  -- unique key
  local mt = {__index = function (t) return t[key] end}
  function setDefault (t,d)
     t[key] = d
     setmetatable(t,mt)
  end
#+END_SRC

*** tracking table accesses

#+BEGIN_SRC lua
  local index = {} -- create private index
  
  local mt = { -- create metatable
     __index = function (t, k)
        print("*access to element " .. tostring(k))
        return t[index][k] -- access the original table
     end,
     __newindex = function (t, k, v)
        print("*update of element " .. tostring(k) ..
                 " to " .. tostring(v))
        t[index][k] = v -- update original table
     end,
  }
  
  __pairs = function (t)
     return function (t, k)
        return next(t[index], k)
     end, t
  end
  
  function track (t)
     local proxy = {}
     proxy[index] = t
     setmetatable(proxy, mt)
     return proxy
  end
  
  t = {}
  tmp = track(t)
  tmp[2]="hello"
  print(tmp[2])
  print("orig:",t[2])
#+END_SRC

*** read-only tables

#+BEGIN_SRC lua
  function readOnly (t)
     local proxy = {}
     local mt = { -- create metatable
        __index = t,
        __newindex = function (t, k, v)
           error("attempt to update a read-only table", 2)
        end
     }
     setmetatable(proxy, mt)
     return proxy
  end
  
  days = readOnly{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}
  
  print(days[1])
  days[2] = "Noday"
#+END_SRC

* the environment

** global-variable declarations

#+BEGIN_SRC lua
  print(xxoo)                     -- nil
  setmetatable(_G,{
                  __newindex=function(_,n)
                     error("attemp to write to undeclared variable " .. n, 2)
                  end,
                  __index=function(_,n)
                     error("attemp to read undeclared variable " .. n, 2)
                  end,
  })
  xxoo="hello"
  print(xxoo)
#+END_SRC

then, we can only use 'rawset' to declare new variables

#+BEGIN_SRC lua
  function declare (name, initval)
     if rawget(_G,name) == nil then
        rawset(_G, name, initval or false)
     end
  end
  
  print(xxoo)                     -- nil
  setmetatable(_G,{
                  __newindex=function(_,n)
                     error("attemp to write to undeclared variable " .. n, 2)
                  end,
                  __index=function(_,n)
                     error("attemp to read undeclared variable " .. n, 2)
                  end,
  })
  
  declare('xxoo', "hello world")
  print(xxoo)
#+END_SRC

** non-global environments

the Lua compiler translates any free name var to _ENV.var,so

#+BEGIN_SRC lua
  var1 = var2 + 3
  -- equal to
  _ENV.var1 = _ENV.var2 + 3
#+END_SRC

Lua treats any chunk as an anonymous function,so Lua compiles original chunk as the following code:

#+BEGIN_SRC lua
  local _ENV = <some value>
     return function (...)
        _ENV.var1 = _ENV.var2 + 3
     end
#+END_SRC

In Lua5.2:

+ Lua compiles any chunk in the scope of an upvalue called \_ENV
+ The compiler translates any free name var to \_ENV.var
+ The load (or loadfile) function initializes the first upvalue of a chunk with the global environment

** using \_ENV

#+BEGIN_SRC lua
  a=3
  local a=2
  print(a)                        -- 2
  print(_ENV.a)                   -- 3
  
  local print,hehe,pi = print, math.sin,math.pi
  _ENV=nil
  
  print(hehe(pi/2))               -- 1
  print(math.cos(pi))             -- lua: qr_6877e3I.lua:6: attempt to index upvalue '_ENV' (a nil value)
#+END_SRC

* modules and packages

#+BEGIN_SRC lua
  local m = require "math"
  print(m.sin(m.pi/2))            -- 1
#+END_SRC

** the require function

The first step of require is to check in table package.loaded whether the module is already loaded

If the module is not loaded yet, require searches for a Lua file with the module name. If it finds a Lua file, it loads it with loadfile. The result of that is a function that we call a loader(The loader is a function that, when called,loads the module)

If require cannot find a Lua file with the module name, it searches for a C library with the module name. If it finds a C library, it loads it with package.loadlib, looking for a function called luaopen\_modname

If the loader returns any value, require returns this value and stores it in the package.loaded table to return the same value in future calls for this same module. If the loader returns no value, require behaves as if the module returned true. 

Without this correction, a subsequent call to require would run the module again

+ renaming a module

for processing different version,we can rename modules with names like 'v1-mod',for instance

+ path searching

the path that *require* use to search for lua files is stored in *package.path*

#+BEGIN_SRC lua
  > print(package.path)
  /usr/local/share/lua/5.2/?.lua;/usr/local/share/lua/5.2/?/init.lua;/usr/local/lib/lua/5.2/?.lua;/usr/local/lib/lua/5.2/?/init.lua;./?.lua
#+END_SRC

When Lua starts, it initializes this variable with the value of the environment variable LUA\_PATH\_5\_2. If this environment variable is not defined, Lua tries the environment variable LUA\_PATH.

If both are not defined, Lua uses a compiled-defined default path

+ searchers

A searcher is simply a function that receives the module name and returns either a loader for that module or nil if it cannot find one

The array package.searchers lists the searchers that require uses. When looking for a module, require calls each searcher in the list passing the modulename, until one of them finds a loader for the module

If the list ends without a positive response, require raises an error

The preload searcher allows the definition of an arbitrary function to load a module. It uses a table, called package.preload, to map module names to loader functions

** the basic approach for writing modules in lua

#+BEGIN_SRC lua
  -- complex.lua
  local M = {}
  
  function M.new (r, i) return {r=r, i=i} end
  
  -- defines constant 'i'
  M.i = M.new(0, 1)
  
  function M.add (c1, c2)
     return M.new(c1.r + c2.r, c1.i + c2.i)
  end
  
  function M.sub (c1, c2)
     return M.new(c1.r - c2.r, c1.i - c2.i)
  end
  
  function M.mul (c1, c2)
     return M.new(c1.r*c2.r - c1.i*c2.i, c1.r*c2.i + c1.i*c2.r)
  end
  
  local function inv (c)
     local n = c.r^2 + c.i^2
     return M.new(c.r/n, -c.i/n)
  end
  
  function M.div (c1, c2)
     return M.mul(c1, inv(c2))
  end
  
  function M.tostring (c)
     return "(" .. c.r .. "," .. c.i .. ")"
  end
  
  return M
  
  -- demo.lua
  local cpx = require "complex"
  print(cpx.tostring(cpx.add(cpx.new(3,4), cpx.i))) -- (3,5)
#+END_SRC

module with export list

#+BEGIN_SRC lua
  -- kumakichi.lua
  local function hello() print("hello world") end
  
  return {
     say = hello
  }
  -- demo.lua
  local k = require "kumakichi"
  k.say()                         -- hello world
  
#+END_SRC

** using environments

#+BEGIN_SRC lua
  -- module setup
  local M = {}
  
  -- Import Section:
  -- declare everything this module needs from outside
  local sqrt = math.sqrt
  local io = io
  
  -- no more external access after this point
  _ENV = nil -- or _ENV = M
#+END_SRC

** submodules and packages

a module named mod.sub is a submodule of mod, a package is a complete tree of modules

* object-orented programming

#+BEGIN_SRC lua
  Account = {balance=0}
  
  -- function Account.withdraw (self,v)
  --    self.balance = self.balance - v
  -- end
  
  -- a,Account=Account,nil
  -- a.withdraw(a,100)
  
  function Account:withdraw (v)   -- using *colon operator* to hide *this*
     self.balance = self.balance - v
  end
  a,Account=Account,nil
  a:withdraw(100)
  
  print(a.balance)
#+END_SRC

** classes

#+BEGIN_SRC lua
  setmetatable(a, {__index = b})
#+END_SRC

After that, a looks up in b for any operation that it *does not have*. To see b as the class of object a is not much more than a change in terminology

#+BEGIN_SRC lua
  Account = {balance=0}
  
  function Account:new (o)
     o = o or {}                  -- create table if user does not provide one
  
     setmetatable(o, self)        -- without the 2 lines, attempt to call method 'deposit' (a nil value)
     self.__index = self          -- When we call Account:new, self is equal to Account
  
     return o
  end
  
  function Account:deposit (v)
     self.balance = self.balance + v
  end
  
  a = Account:new()
  a:deposit(100.00)               -- getmetatable(a).__index.deposit(a, 100.00)
  print(a.balance)
#+END_SRC

** inheritance

#+BEGIN_SRC lua
  Account = {balance=0}
  
  function Account:new (o)
     o = o or {}                  -- create table if user does not provide one
  
     setmetatable(o, self)        -- without the 2 lines, attempt to call method 'deposit' (a nil value)
     self.__index = self
  
     return o
  end
  
  function Account:deposit (v)
     self.balance = self.balance + v
  end
  
  -- SpecialAccount inherits new from Account, like any other method. This time,
  -- however, when new executes, its self parameter will refer to SpecialAccount.
  -- Therefore, the metatable of s will be SpecialAccount, whose value at field
  -- __index is also SpecialAccount. So, s inherits from SpecialAccount, which
  -- inherits from Account
  
  BossAccount = Account:new()
  
  -- redefine 'deposit'
  function BossAccount:deposit (v)
     if v + self.balance < self:getLeast() then
        self.balance = self:getLeast()
     end
  end
  
  function BossAccount:getLeast ()
     return self.atleast or 0
  end
  
  s = BossAccount:new{atleast=10000.00}
  s:deposit(-88)
  print(s.balance)
#+END_SRC

** multipule inheritance

#+BEGIN_SRC lua
  -- look up for 'k' in list of tables 'plist'
  local function search (k, plist)
     for i = 1, #plist do
        local v = plist[i][k]      -- try 'i'-th superclass
        if v then return v end
     end
  end
  
  function createClass (...)
     local c = {}   -- new class
     local parents = {...}
     -- class will search for each method in the list of its parents
     setmetatable(c, {__index = function (t, k)
                         return search(k, parents)
     end})
  
     -- prepare 'c' to be the metatable of its instances
     c.__index = c
  
     -- define a new constructor for this new class
     function c:new (o)
        o = o or {}
        setmetatable(o, c)
        return o
     end
     return c
  end                             -- return new class
  
  -- xxxxxxxxxxxxxxxxxxxxxxxxx
  
  Named = {}
  
  function Named:getname ()
     return self.name
  end
  
  function Named:setname (n)
     self.name = n
  end
  
  Account = {balance=0}
  
  function Account:new (o)
     o = o or {}                  -- create table if user does not provide one
     return o
  end
  
  function Account:deposit (v)
     self.balance = self.balance + v
  end
  -- xxxxxxxxxxxxxxxxxxxxxxx
  NamedAccount = createClass(Account, Named)
  account = NamedAccount:new{name = "Paul"}
  account:deposit(88)
  print(account:getname(), account.balance)        -- Paul
#+END_SRC

** single-method approach

#+BEGIN_SRC lua
function newObject (value)
   return function (action, v)
      if action == "get" then return value
      elseif action == "set" then value = v
      else error("invalid action")
      end
   end
end

d = newObject(0)
print(d("get"))                 -- 0
d("set", 10)
print(d("get"))                 -- 10
#+END_SRC

* weak tables and finalizers

** weak tables

The weakness of a table is given by the field __mode of its metatable. The value of this field, when present, should be a string: 

if this string is "k", the keys in the table are weak; if this string is "v", the values in the table are weak; if this string is "kv", both keys and values are weak

#+BEGIN_SRC lua
  a = {}
  b = {__mode = "k"}
  setmetatable(a, b)              -- now 'a' has weak keys
  
  key = {}                        -- creates first key
  a[key] = 1
  
  key = {}                        -- creates second key
  a[key] = 2
  collectgarbage()                -- forces a garbage collection cycle
  for k, v in pairs(a) do print(v) end
#+END_SRC

As there is no other reference to the first key, this key is collected and the corresponding entry in the table is removed

The second key, however, is still anchored in variable key, so it is not collected

** memorize functions

#+BEGIN_SRC lua
  local results = {}
  function mem_loadstring (s)
     local res = results[s]
     if res == nil then
        res = assert(load(s))
        results[s] = res
     end
     return res
  end
#+END_SRC

** revisiting tables with default values

+ solution 1

#+BEGIN_SRC lua
  local defaults = {}
  setmetatable(defaults, {__mode="k"})
  
  local mt = {__index = function (t) return defaults[t] end}
  
  function setDefault (t, d)
     defaults[t] = d
     setmetatable(t, mt)
  end
#+END_SRC

+ solution 2

#+BEGIN_SRC lua
  local metas = {}
  setmetatable(metas,{__mode="v"})
  
  function setDefault (t,d)
     local mt = metas[d]
     if mt == nil then
        mt = {__index = function () return d end}
        metas[d] = mt
     end
     setmetatable(t,mt)
  end
#+END_SRC

** finalizers

#+BEGIN_SRC lua
  o = {x = "hi"}
  setmetatable(o, {__gc = function (o) print(o.x) end})
  o = nil
  collectgarbage()                -- hi
#+END_SRC

#+BEGIN_SRC lua
  mt = {__gc = function (o) print(o[1]) end}
  list = nil
  for i = 1, 3 do
     list = setmetatable({i, link = list}, mt)
  end
  list = nil
  collectgarbage()
  -- 3
  -- 2
  -- 1
#+END_SRC

* the mathematical library

#+BEGIN_SRC lua
  math.randomseed(os.time())
  print(math.random())
#+END_SRC

* the bitwise library

Because and, or, and not are reserved words in Lua, these operations are called respectively band, bor, and bnot

#+BEGIN_SRC lua
  function printx (x)
     print(string.format("0x%X", x))
  end
  
  printx(bit32.band(0xDF, 0xFD))  -- 0xDD
  printx(bit32.bor(0xD0, 0x0D))   -- 0xDD
  printx(bit32.bxor(0xD0, 0xFF))  -- 0x2F
  printx(bit32.bnot(0))           -- 0xFFFFFFFF
  
  printx(bit32.rshift(0xDF, 4))   -- 0xD
  printx(bit32.lshift(0xDF, 4))   -- 0xDF0
  printx(bit32.rshift(-1, 28))    -- 0xF
  printx(bit32.arshift(-1, 28))   -- 0xFFFFFFFF
  printx(bit32.lrotate(0xABCDEF01, 4)) -- 0xBCDEF01A
  printx(bit32.rrotate(0xABCDEF01, 4)) -- 0x1ABCDEF0
  
#+END_SRC

Function btest performs the same operation as band, but returns a boolean indicating whether the result is different from zero

#+BEGIN_SRC lua
  print(bit32.btest(12,1))        -- false
  print(bit32.btest(13,1))        -- true
#+END_SRC

bit32.extract(x, f, w) returns w bits from x, starting at bit f

This operation counts bits from 0 to 31. If not provided, the field width defaults to one bit

#+BEGIN_SRC lua
  function printx (x)
     print(string.format("0x%X", x))
  end
  
  printx(bit32.extract(0xABCDEF01, 4, 8)) -- 0xF0
  printx(bit32.extract(0xABCDEF01, 20, 12)) -- 0xABC
  printx(bit32.extract(0xABCDEF01, 0, 12))  -- 0xF01
  printx(bit32.extract(0x8, 3))             -- 0x1
#+END_SRC

The reverse of extract is replace, which replaces a bit field into a number

#+BEGIN_SRC lua
  printx(bit32.replace(0xABCDEF01, 0x55, 4, 8)) -- 0xABCDE551
  printx(bit32.replace(0xABCDEF01, 0x0, 4, 8))  -- 0xABCDE001
#+END_SRC

* the table library

** insert and remove

try *t[#t + 1] = line* to append elements to a list

#+BEGIN_SRC lua
  t = {}
  
  for i=7,11 do
     t[#t+1] = i
  end
  
  print(table.remove(t))          -- 11
  print(table.remove(t,1))        -- 7
  print(#t)                       -- 3
  
  table.insert(t,2,99)
  
  for k,v in pairs(t) do
     print(k,v)
  end
  -- 1    8
  -- 2    99
  -- 3    9
  -- 4    10
#+END_SRC

** sort

#+BEGIN_SRC lua
  lines = {
     luaH_present = 48,
     luaH_set = 10,
     luaH_get = 24,
  }
  
  a = {}
  for n in pairs(lines) do a[#a + 1] = n end
  table.sort(a)
  for _, n in ipairs(a) do print(n) end
  
  function pairsByKeys (t, f)
     local a = {}
     for n in pairs(t) do a[#a + 1] = n end
     table.sort(a, f)
  
     local i = 0                  -- iterator variable
     return function ()           -- iterator function
        i = i+1
        return a[i],t[a[i]]
     end
  end
  
  for name, line in pairsByKeys(lines) do
     print(name, line)
  end
#+END_SRC

** concatenation

#+BEGIN_SRC lua
  function rconcat (l, sep)
     if type(l) ~= "table" then return l end
     local res = {}
     for i = 1, #l do
        res[i] = rconcat(l[i], sep)
     end
     return table.concat(res, sep)
  end
  
  print(rconcat{{"a", {" nice"}}, " and", {{" long"}, {" list"}}})
  print(rconcat({{"a", {" nice"}}, " and", {{" long"}, {" list"}}},' - '))
#+END_SRC

* the string library

** basic string functions

The call string.sub(s, i, j) extracts a piece of the string s, from the i-th to the j-th character inclusive. 

In Lua, *the first character of a string has index 1* (what can i say?...)

the index 1 refers to the last character in a string, 2 to the previous one, and so on

#+BEGIN_SRC lua
  s = "[in brackets]"
  print(s:sub(2, -2))             -- in brackets
#+END_SRC

#+BEGIN_SRC lua
  print(string.char(97))          -- a
  print(string.byte("abc", 2))    -- 98
#+END_SRC

** pattern-matching functions

*** The string.find function

#+BEGIN_SRC lua
  s = "hello world"
  s_start, s_end = string.find(s, "llo")
  print(s_start,s_end)            -- 3 5
#+END_SRC

*** The string.match function

#+BEGIN_SRC lua
  date = "Today is 17/7/1990"
  d = string.match(date, "%d+/%d+/%d+")
  print(d)                        -- 17/7/1990
#+END_SRC

*** The string.gsub function

The string.gsub function has three mandatory parameters: a subject string, a pattern, and a replacement string

An optional fourth parameter limits the number of substitutions to be made

#+BEGIN_SRC lua
  s = string.gsub("lili lucy", "l", "x")
  print(s)                        -- xixi xucy
  print(string.gsub("lili lucy", "l", "x", 2)) -- xixi lucy   2
  
#+END_SRC

*** The string.gmatch function

The string.gmatch function returns a function that iterates over all occurrences of a pattern in a string

#+BEGIN_SRC lua
  date = "Today is 17/7/1990, tomorrow is 18/7/1990, the day after tomorrow is 19/7/1990,"
  d = string.gmatch(date, "[%a%s]* is %d+/%d+/%d+")
  
  for x in d do
     print(x)
  end
#+END_SRC

** patterns

all character classes

#+BEGIN_SRC lua
 .    all characters
%a    letters
%c    control characters
%d    digits
%g    printable characters except spaces
%l    lower-case letters
%p    punctuation characters
%s    space characters
%u    upper-case letters
%w    alphanumeric characters
%x    hexadecimal digits
#+END_SRC

Patterns in Lua offer four modifiers

#+BEGIN_SRC lua
\+    1 or more repetitions
\*    0 or more repetitions
-    0 or more lazy repetitions
?    optional (0 or 1 occurrence)
#+END_SRC

** captures

The *capture* mechanism allows a pattern to yank parts of the subject string that match parts of the pattern for further use

#+BEGIN_SRC lua
  pair = "name = Anna"
  key, value = string.match(pair, "(%a+)%s*=%s*(%a+)")
  print(key, value) --> name Anna
#+END_SRC

#+BEGIN_SRC lua
  s = [[then he said: "it's all right"!]]
  q, quotedPart = string.match(s, "([\"])(.-)%1")
  print(quotedPart) --> it's all right
  print(q)
#+END_SRC

the item "%0" is changed to the whole match

** replacements

Instead of a string, we can use either a function or a table as the third argument to string.gsub

#+BEGIN_SRC lua
name = "Lua"
status = "great"

function expand (s)
   return (string.gsub(s, "$(%w+)", {name="hello",status="world"}))
end

print(expand("$name is $status, isn't it?"))
#+END_SRC

** URL Encoding

#+BEGIN_SRC lua
  function escape (s)
     s = string.gsub(s, "[&=+%%%c]", function (c)
                        return string.format("%%%02X", string.byte(c))
     end)
     s = string.gsub(s, " ", "+")
     return s
  end
  
  print(escape("query = a+b = c"))
  
  function unescape (s)
     s = string.gsub(s, "+", " ")
     s = string.gsub(s, "%%(%x%x)", function (h)
                        return string.char(tonumber(h, 16))
     end)
     return s
  end
  
  print(unescape("query+%3D+a%2Bb+%3D+c"))
#+END_SRC

** tab expansion

*()* captures its position in the subject string, as a number

#+BEGIN_SRC lua
  print(string.match("hello", "()lo()")) -- 4 6
#+END_SRC

* the i/o library

** the simple i/o model

+ Unlike print, write adds no extra characters to the output, such as tabs or newlines

+ write allows you to redirect your output, whereas print always uses the standard output

+ print automatically applies tostring to its arguments; this is handy for debugging, but it can hide bugs if you are not paying attention to your output

The io.read function reads strings from the current input file. Its arguments control what to read

#+BEGIN_SRC lua
  "*a"    reads the whole file                    
  "*l"    reads the next line (without newline)   
  "*L"    reads the next line (with newline)      
  "*n"    reads a number                          
  num     reads a string with up to num characters
#+END_SRC

** the complete i/o model

#+BEGIN_SRC lua
  local f = assert(io.open("demo.lua", "r"))
  local t = f:read("*a")
  f:close()
  print(t)                        -- self-printing
#+END_SRC

The I/O library offers handles for the three predefined C streams: io.stdin,io.stdout, and io.stderr

#+BEGIN_SRC lua
  io.stderr:write("hello")
#+END_SRC

if you want to change the current input file temporarily

also self-printing

#+BEGIN_SRC lua
  local temp = io.input()         -- save current file
  io.input("demo.lua")            -- open 'demo.lua' as new current file
  print(io.read("*a"))
  io.input():close()
  io.input(temp)
#+END_SRC

*** a small performance trick

If you want to handle big files with maximum performance, the fastest way is to read them in reasonably large chunks (e.g., 8 kB each)

To avoid the problem of breaking lines in the middle, you simply ask to read a chunk plus a line:

#+BEGIN_SRC lua
  local lines, rest = f:read(BUFSIZE, "*l")
#+END_SRC

The variable rest will get the rest of any line broken by the chunk

*** binary files

The simple-model functions io.input and io.output always open a file *in text mode* (the default)

#+BEGIN_SRC lua
  -- dos to unix
  local fin = assert(io.open(arg[1], "rb"))
  local fout = assert(io.open(arg[2], "wb"))
  
  local data = fin:read("*a")
  data = string.gsub(data, "\r\n", "\n")
  fout:write(data)
  
  fout:close()
  fin:close()
#+END_SRC

** other operations on files

The tmpfile function returns a handle for a temporary file, open in read/write mode

io.flush() to flush the current output file; as a method, f:flush(), to flush a particular file f

The setvbuf method sets the buffering mode of a stream,first argument is a string("no","line","full").For the last two options, setvbuf accepts an optional second argument with the buffer size

The seek method can both get and set the current position of a file. Its general form is f:seek(whence,offset) -- whence can be "set","cur" or "end"

#+BEGIN_SRC lua
  function fileSize (fp)
     local old = fp:seek()    -- get current position
     local size = fp:seek("end") -- get file size
     fp:seek("set", old)         -- restore
     return size
  end
  
  f = io.open("demo.lua","r")
  print(fileSize(f))
  f:close()
#+END_SRC

* the operating system library

** date and time

date tables have the following significant fields

#+BEGIN_SRC lua
  year    a full year                             
  mont    01–12                                   h
  day     01–31                                   
  hour    00–23                                   
  min     00–59                                   
  sec     00–59                                   
  isdst   a boolean, true if daylight saving is on
#+END_SRC

calculate unix time stamp

#+BEGIN_SRC lua
print(os.time{year=1997, month=1, day=1, hour=0})
#+END_SRC

For numeric values, the table shows also their range of possible values

#+BEGIN_SRC lua
  %a    abbreviated weekday name (e.g., Wed)     
  %A    full weekday name (e.g., Wednesday)      
  %b    abbreviated month name (e.g., Sep)       
  %B    full month name (e.g., September)        
  %c    date and time (e.g., 09/16/98 23:48:10)  
  %d    day of the month (16) [01–31]            
  %H    hour, using a 24-hour clock (23) [00–23] 
  %I    hour, using a 12-hour clock (11) [01–12] 
  %j    day of the year (259) [001–366]          
  %M    minute (48) [00–59]                      
  %m    month (09) [01–12]                       
  %p    either "am" or "pm" (pm)             
  %S    second (10) [00–60]                      
  %w    weekday (3) [0–6 = Sunday–Saturday]      
  %x    date (e.g., 09/16/98)                    
  %X    time (e.g., 23:48:10)                    
  %y    two-digit year (98) [00–99]              
  %Y    full year (1998)                         
  %%    the character '%'
#+END_SRC

#+BEGIN_SRC lua
  print(os.date("a %A in %B"))    -- a Wednesday in November
#+END_SRC

** other system calls

#+BEGIN_SRC lua
  print(os.getenv("HOME"))        -- /home/san
  print(os.execute("ls -ld ~"))   -- drwxr-xr-x 159 san san 16384 11月 26 14:57 /home/san
  -- true exit    0
#+END_SRC

* the debug library

** Introspective Facilities

The main introspective function in the debug library is the debug.getinfo function. Its first parameter can be a function or a stack level

When you call debug.getinfo(foo) for some function foo, you get a table with some data about this function

+ source

	where the function was defined

+ short\_src

	a short version of source (up to 60 characters)

+ linedefined

	number of the first line of the source where the function wasdefined

+ lastlinedefined

	number of the last line of the source where the function was defined

+ what

	what this function is. "C" if it is a C function, or "main" if it is the main part of a Lua chunk.

+ name

	a reasonable name for the function

+ namewhat

	what the previous field means. This field can be "global", "local","method", "field", or "" (the empty string). The empty string means that Lua did not find a name for the function

+ nups

    number of upvalues of that function

+ activelines

	a table representing the set of active lines of the function

+ func

	the function itself; see later

To achieve better performance, getinfo has an optional second parameter that selects what information to get

#+BEGIN_SRC lua
  'n'    selects name and namewhat
  'f'    selects func
  'S'    selects source, short_src, what, linedefined, and lastlinedefined
  'l'    selects currentline
  'L'    selects activelines
  'u'    selects nup
#+END_SRC

*** Accessing local variables

We can inspect the local variables of any active function with debug.getlocal

This function has two parameters: *the stack level* and a *variable index*

#+BEGIN_SRC lua
  function foo (a, b)
     local x
     do local c = a - b end
     local a = 1
     while true do
        local name, value = debug.getlocal(1, a)
        if not name then break end
        print(name, value)
        a = a + 1
     end
  end
  
  foo(10,20)
#+END_SRC

You can also change the values of local variables, with debug.setlocal. Its first two parameters are a stack level and a variable index, like in getlocal

Its third parameter is the new value for this variable. It returns the variable name or nil if the variable index is out of scope

** hooks
The hook mechanism of the debug library allows us to register a function to be called at specific events as a program runs

There are four kinds of events that can trigger a hook:

+ call events happen every time Lua calls a function;
+ return events happen every time a function returns;
+ line events happen when Lua starts executing a new line of code;
+ count events happen after a given number of instructions.

debug.sethook with two or three arguments: 

the first argument is the hook function

the second argument is a mask string('c'-'call', 'r'-'run', 'l'-'line')

and the optional third argument is a number that describes at what frequency we want to get count events

#+BEGIN_SRC lua
  function foo (a)
     local x = a * 2
     print(x)
  end
  
  debug.sethook(print,"l")
  foo(10)
#+END_SRC

* An Overview of the C API

** a first example

#+BEGIN_SRC c
  #include <stdio.h>
  #include <string.h>
  #include <lua.h>
  #include <lauxlib.h>
  #include <lualib.h>
  
  /* build with : -llua -lm -ldl */
  int main(void)
  {
      char buff[256];
      int error;
  
      lua_State *L = luaL_newstate(); /* opens Lua */
      luaL_openlibs(L);   /* opens the standard libraries */
  
      while (fgets(buff, sizeof(buff), stdin) != NULL) {
          error = luaL_loadstring(L, buff) || lua_pcall(L, 0, 0, 0);
          if (error) {
              fprintf(stderr, "%s\n", lua_tostring(L, -1));
              lua_pop(L, 1);  /* pop error message from the stack */
          }
      }
  
      lua_close(L);
      return 0;
  }
#+END_SRC

** the stack

*** pushing elements

#+BEGIN_SRC c
  void lua_pushnil(lua_State * L);
  void lua_pushboolean(lua_State * L, int bool);
  void lua_pushnumber(lua_State * L, lua_Number n);  /* for doubles */
  void lua_pushinteger(lua_State * L, lua_Integer n);  /* for integers */
  void lua_pushunsigned(lua_State * L, lua_Unsigned n);  /* for unsigned integers */
  void lua_pushlstring(lua_State * L, const char *s, size_t len);
  void lua_pushstring(lua_State * L, const char *s);
#+END_SRC

lua_checkstack checks whether the stack has enough space for your needs:

#+BEGIN_SRC c
  int lua_checkstack(lua_State * L, int sz);
#+END_SRC

*** Querying elements

To check whether an element has a specific type, the API offers a family of functions lua\_is*, where the * can be any Lua type. 

So, there are lua\_isnumber,lua\_isstring, lua\_istable, and the like. All these functions have the same prototype:

#+BEGIN_SRC c
  int lua_is* (lua_State * L, int index);
#+END_SRC

There is also a function lua_type, which returns the type of an element in the stack. Each type is represented by a constant defined in the header file lua.h:

LUA_TNIL, LUA_TBOOLEAN, LUA_TNUMBER, LUA_TSTRING, LUA_TTABLE, LUA_TTHREAD, LUA_TUSERDATA, and LUA_TFUNCTION

To get a value from the stack, there are the lua\_to* functions:

#+BEGIN_SRC c
  int lua_toboolean(lua_State * L, int index);
  const char *lua_tolstring(lua_State * L, int index, size_t * len);
  lua_Number lua_tonumber(lua_State * L, int index);
  lua_Integer lua_tointeger(lua_State * L, int index);
  lua_Unsigned lua_tounsigned(lua_State * L, int idx);
#+END_SRC

*** other stack operations

operations for generic stack manipulation:

#+BEGIN_SRC c
  int lua_gettop(lua_State * L);
  void lua_settop(lua_State * L, int index);
  void lua_pushvalue(lua_State * L, int index);
  void lua_remove(lua_State * L, int index);
  void lua_insert(lua_State * L, int index);
  void lua_replace(lua_State * L, int index);
  void lua_copy(lua_State * L, int fromidx, int toidx);
#+END_SRC

